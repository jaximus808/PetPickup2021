"use strict";

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var onFinished = require('on-finished');

var parseRequest = require('parse-request');

var _require = require('./utils'),
    isFunction = _require.isFunction,
    isUndefined = _require.isUndefined;

module.exports = function () {
  var _this = this;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var isExpress = !isUndefined(args[2]) && isFunction(args[2]);
  var request = isExpress ? args[0] : args[0].req;
  var res = isExpress ? args[1] : args[0].res; // const request = isExpress ? args[0] : args[0].request;
  // const response = isExpress ? args[1] : args[0].response;

  var ctx = args[0];
  var next = isExpress ? args[2] : args[1];
  var logger = {}; //
  // Note that `params` is not named `args` because ESLint doesn't warn:
  // <https://github.com/eslint/eslint/issues/11915>
  //

  Object.keys(this.logger).filter(function (key) {
    return isFunction(_this.logger[key]);
  }).forEach(function (key) {
    logger[key] = function () {
      var _this$logger;

      for (var _len2 = arguments.length, parameters = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        parameters[_key2] = arguments[_key2];
      }

      if (isUndefined(parameters[1])) parameters[1] = {};else parameters[1] = _this.parseArg(parameters[1]); // add `request` object to metadata

      Object.assign(parameters[1], parseRequest(Object.assign(isExpress ? {
        req: request
      } : {
        ctx: ctx
      }, //
      // this symbol was not added until Node v7.7.0
      // and we try to support Node v6.4+
      // <https://github.com/nodejs/node/issues/17745>
      //
      // <https://github.com/nodejs/node/blob/v7.10.0/lib/_http_outgoing.js#L379-L380>
      // <https://github.com/nodejs/node/blob/v7.7.0/lib/_http_outgoing.js#L379-L380>
      // <https://github.com/nodejs/node/blob/v6.4.0/lib/_http_outgoing.js#L351-L352>
      //
      // Note that for the fallback `_headers` all the keys are lowercased
      //
      // But note that in node v12.4.0 for instance this prop is deprecated
      // <https://github.com/nodejs/node/blob/v12.4.0/lib/_http_outgoing.js#L116>
      // So we are left with either the Symbol or use of `getHeaders`
      //
      // HOWEVER automatic properties like Date header aren't
      // set when you do `getHeaders`, they are only written to `_header`
      // and so we need `parse-request` to parse the `responseHeaders`
      // as a String using `http-headers`...
      // <https://github.com/nodejs/node/issues/28302>
      //
      // note that HTTP2 responses do not have a String value
      // for `res._header`, and instead is a Boolean value
      // <https://github.com/nodejs/node/issues/30894>
      // <https://github.com/cabinjs/cabin/issues/133>
      {
        responseHeaders: typeof res._header === 'string' ? res._header : typeof res.getHeaders === 'function' ? res.getHeaders() : null
      }, _this.config.parseRequest)));
      return (_this$logger = _this.logger)[key].apply(_this$logger, _toConsumableArray([].slice.call(parameters)));
    };
  }); // upon completion of a response we need to log it

  onFinished(res, function (err) {
    if (err) logger.error(err);
    var level = 'info';
    if (res.statusCode >= 500) level = 'error';else if (res.statusCode >= 400) level = 'warn';

    var message = _this.config.message(Object.assign({
      level: level,
      req: request,
      res: res
    }, isExpress ? {} : {
      ctx: args[0]
    }));

    if (err) logger[level](message, {
      err: err
    });else logger[level](message);
  }); // add `log` (shorthand) and `logger` methods
  // `req.log`
  // `res.log`
  // `ctx.req`
  // `ctx.res`
  // `ctx.request`
  // `ctx.response`
  // <https://github.com/pinojs/koa-pino-logger/issues/14>
  // <https://github.com/pinojs/koa-pino-logger/blob/master/logger.js#L11>
  // <https://github.com/pinojs/pino-http/blob/master/logger.js#L55>

  if (isExpress) {
    request.log = logger;
    res.log = logger;
    request.logger = logger;
    res.logger = logger;
  } else {
    var _ctx = args[0];
    _ctx.log = logger;
    _ctx.logger = logger;
    _ctx.request.log = logger;
    _ctx.request.logger = logger;
    _ctx.response.log = logger;
    _ctx.response.logger = logger;
  }

  return next();
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9taWRkbGV3YXJlLmpzIl0sIm5hbWVzIjpbIm9uRmluaXNoZWQiLCJyZXF1aXJlIiwicGFyc2VSZXF1ZXN0IiwiaXNGdW5jdGlvbiIsImlzVW5kZWZpbmVkIiwibW9kdWxlIiwiZXhwb3J0cyIsImFyZ3MiLCJpc0V4cHJlc3MiLCJyZXF1ZXN0IiwicmVxIiwicmVzIiwiY3R4IiwibmV4dCIsImxvZ2dlciIsIk9iamVjdCIsImtleXMiLCJmaWx0ZXIiLCJrZXkiLCJmb3JFYWNoIiwicGFyYW1ldGVycyIsInBhcnNlQXJnIiwiYXNzaWduIiwicmVzcG9uc2VIZWFkZXJzIiwiX2hlYWRlciIsImdldEhlYWRlcnMiLCJjb25maWciLCJzbGljZSIsImNhbGwiLCJlcnIiLCJlcnJvciIsImxldmVsIiwic3RhdHVzQ29kZSIsIm1lc3NhZ2UiLCJsb2ciLCJyZXNwb25zZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFNQSxVQUFVLEdBQUdDLE9BQU8sQ0FBQyxhQUFELENBQTFCOztBQUNBLElBQU1DLFlBQVksR0FBR0QsT0FBTyxDQUFDLGVBQUQsQ0FBNUI7O2VBQ29DQSxPQUFPLENBQUMsU0FBRCxDO0lBQW5DRSxVLFlBQUFBLFU7SUFBWUMsVyxZQUFBQSxXOztBQUVwQkMsTUFBTSxDQUFDQyxPQUFQLEdBQWlCLFlBQW1CO0FBQUE7O0FBQUEsb0NBQU5DLElBQU07QUFBTkEsSUFBQUEsSUFBTTtBQUFBOztBQUNsQyxNQUFNQyxTQUFTLEdBQUcsQ0FBQ0osV0FBVyxDQUFDRyxJQUFJLENBQUMsQ0FBRCxDQUFMLENBQVosSUFBeUJKLFVBQVUsQ0FBQ0ksSUFBSSxDQUFDLENBQUQsQ0FBTCxDQUFyRDtBQUNBLE1BQU1FLE9BQU8sR0FBR0QsU0FBUyxHQUFHRCxJQUFJLENBQUMsQ0FBRCxDQUFQLEdBQWFBLElBQUksQ0FBQyxDQUFELENBQUosQ0FBUUcsR0FBOUM7QUFDQSxNQUFNQyxHQUFHLEdBQUdILFNBQVMsR0FBR0QsSUFBSSxDQUFD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bmlzaGVkJyk7XG5jb25zdCBwYXJzZVJlcXVlc3QgPSByZXF1aXJlKCdwYXJzZS1yZXF1ZXN0Jyk7XG5jb25zdCB7IGlzRnVuY3Rpb24sIGlzVW5kZWZpbmVkIH0gPSByZXF1aXJlKCcuL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgY29uc3QgaXNFeHByZXNzID0gIWlzVW5kZWZpbmVkKGFyZ3NbMl0pICYmIGlzRnVuY3Rpb24oYXJnc1syXSk7XG4gIGNvbnN0IHJlcXVlc3QgPSBpc0V4cHJlc3MgPyBhcmdzWzBdIDogYXJnc1swXS5yZXE7XG4gIGNvbnN0IHJlcyA9IGlzRXhwcmVzcyA/IGFyZ3NbMV0gOiBhcmdzWzBdLnJlcztcbiAgLy8gY29uc3QgcmVxdWVzdCA9IGlzRXhwcmVzcyA/IGFyZ3NbMF0gOiBhcmdzWzBdLnJlcXVlc3Q7XG4gIC8vIGNvbnN0IHJlc3BvbnNlID0gaXNFeHByZXNzID8gYXJnc1sxXSA6IGFyZ3NbMF0ucmVzcG9uc2U7XG4gIGNvbnN0IGN0eCA9IGFyZ3NbMF07XG4gIGNvbnN0IG5leHQgPSBpc0V4cHJlc3MgPyBhcmdzWzJdIDogYXJnc1sxXTtcbiAgY29uc3QgbG9nZ2VyID0ge307XG4gIC8vXG4gIC8vIE5vdGUgdGhhdCBgcGFyYW1zYCBpcyBub3QgbmFtZWQgYGFyZ3NgIGJlY2F1c2UgRVNMaW50IGRvZXNuJ3Qgd2FybjpcbiAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9lc2xpbnQvZXNsaW50L2lzc3Vlcy8xMTkxNT5cbiAgLy9cbiAgT2JqZWN0LmtleXModGhpcy5sb2dnZXIpXG4gICAgLmZpbHRlcigoa2V5KSA9PiBpc0Z1bmN0aW9uKHRoaXMubG9nZ2VyW2tleV0pKVxuICAgIC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGxvZ2dlcltrZXldID0gKC4uLnBhcmFtZXRlcnMpID0+IHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHBhcmFtZXRlcnNbMV0pKSBwYXJhbWV0ZXJzWzFdID0ge307XG4gICAgICAgIGVsc2UgcGFyYW1ldGVyc1sxXSA9IHRoaXMucGFyc2VBcmcocGFyYW1ldGVyc1sxXSk7XG4gICAgICAgIC8vIGFkZCBgcmVxdWVzdGAgb2JqZWN0IHRvIG1ldGFkYXRhXG4gICAgICAgIE9iamVjdC5hc3NpZ24oXG4gICAgICAgICAgcGFyYW1ldGVyc1sxXSxcbiAgICAgICAgICBwYXJzZVJlcXVlc3QoXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgICBpc0V4cHJlc3MgPyB7IHJlcTogcmVxdWVzdCB9IDogeyBjdHggfSxcbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gdGhpcyBzeW1ib2wgd2FzIG5vdCBhZGRlZCB1bnRpbCBOb2RlIHY3LjcuMFxuICAgICAgICAgICAgICAvLyBhbmQgd2UgdHJ5IHRvIHN1cHBvcnQgTm9kZSB2Ni40K1xuICAgICAgICAgICAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8xNzc0NT5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3Y3LjEwLjAvbGliL19odHRwX291dGdvaW5nLmpzI0wzNzktTDM4MD5cbiAgICAgICAgICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3Y3LjcuMC9saWIvX2h0dHBfb3V0Z29pbmcuanMjTDM3OS1MMzgwPlxuICAgICAgICAgICAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjYuNC4wL2xpYi9faHR0cF9vdXRnb2luZy5qcyNMMzUxLUwzNTI+XG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBmb3IgdGhlIGZhbGxiYWNrIGBfaGVhZGVyc2AgYWxsIHRoZSBrZXlzIGFyZSBsb3dlcmNhc2VkXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIEJ1dCBub3RlIHRoYXQgaW4gbm9kZSB2MTIuNC4wIGZvciBpbnN0YW5jZSB0aGlzIHByb3AgaXMgZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEyLjQuMC9saWIvX2h0dHBfb3V0Z29pbmcuanMjTDExNj5cbiAgICAgICAgICAgICAgLy8gU28gd2UgYXJlIGxlZnQgd2l0aCBlaXRoZXIgdGhlIFN5bWJvbCBvciB1c2Ugb2YgYGdldEhlYWRlcnNgXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIEhPV0VWRVIgYXV0b21hdGljIHByb3BlcnRpZXMgbGlrZSBEYXRlIGhlYWRlciBhcmVuJ3RcbiAgICAgICAgICAgICAgLy8gc2V0IHdoZW4geW91IGRvIGBnZXRIZWFkZXJzYCwgdGhleSBhcmUgb25seSB3cml0dGVuIHRvIGBfaGVhZGVyYFxuICAgICAgICAgICAgICAvLyBhbmQgc28gd2UgbmVlZCBgcGFyc2UtcmVxdWVzdGAgdG8gcGFyc2UgdGhlIGByZXNwb25zZUhlYWRlcnNgXG4gICAgICAgICAgICAgIC8vIGFzIGEgU3RyaW5nIHVzaW5nIGBodHRwLWhlYWRlcnNgLi4uXG4gICAgICAgICAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzI4MzAyPlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBub3RlIHRoYXQgSFRUUDIgcmVzcG9uc2VzIGRvIG5vdCBoYXZlIGEgU3RyaW5nIHZhbHVlXG4gICAgICAgICAgICAgIC8vIGZvciBgcmVzLl9oZWFkZXJgLCBhbmQgaW5zdGVhZCBpcyBhIEJvb2xlYW4gdmFsdWVcbiAgICAgICAgICAgICAgLy8gPGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzA4OTQ+XG4gICAgICAgICAgICAgIC8vIDxodHRwczovL2dpdGh1Yi5jb20vY2FiaW5qcy9jYWJpbi9pc3N1ZXMvMTMzPlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXJzOlxuICAgICAgICAgICAgICAgICAgdHlwZW9mIHJlcy5faGVhZGVyID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICA/IHJlcy5faGVhZGVyXG4gICAgICAgICAgICAgICAgICAgIDogdHlwZW9mIHJlcy5nZXRIZWFkZXJzID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgID8gcmVzLmdldEhlYWRlcnMoKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdGhpcy5jb25maWcucGFyc2VSZXF1ZXN0XG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmxvZ2dlcltrZXldKC4uLltdLnNsaWNlLmNhbGwocGFyYW1ldGVycykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgLy8gdXBvbiBjb21wbGV0aW9uIG9mIGEgcmVzcG9uc2Ugd2UgbmVlZCB0byBsb2cgaXRcbiAgb25GaW5pc2hlZChyZXMsIChlcnIpID0+IHtcbiAgICBpZiAoZXJyKSBsb2dnZXIuZXJyb3IoZXJyKTtcbiAgICBsZXQgbGV2ZWwgPSAnaW5mbyc7XG4gICAgaWYgKHJlcy5zdGF0dXNDb2RlID49IDUwMCkgbGV2ZWwgPSAnZXJyb3InO1xuICAgIGVsc2UgaWYgKHJlcy5zdGF0dXNDb2RlID49IDQwMCkgbGV2ZWwgPSAnd2Fybic7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuY29uZmlnLm1lc3NhZ2UoXG4gICAgICBPYmplY3QuYXNzaWduKFxuICAgICAgICB7IGxldmVsLCByZXE6IHJlcXVlc3QsIHJlcyB9LFxuICAgICAgICBpc0V4cHJlc3MgPyB7fSA6IHsgY3R4OiBhcmdzWzBdIH1cbiAgICAgIClcbiAgICApO1xuICAgIGlmIChlcnIpIGxvZ2dlcltsZXZlbF0obWVzc2FnZSwgeyBlcnIgfSk7XG4gICAgZWxzZSBsb2dnZXJbbGV2ZWxdKG1lc3NhZ2UpO1xuICB9KTtcbiAgLy8gYWRkIGBsb2dgIChzaG9ydGhhbmQpIGFuZCBgbG9nZ2VyYCBtZXRob2RzXG4gIC8vIGByZXEubG9nYFxuICAvLyBgcmVzLmxvZ2BcbiAgLy8gYGN0eC5yZXFgXG4gIC8vIGBjdHgucmVzYFxuICAvLyBgY3R4LnJlcXVlc3RgXG4gIC8vIGBjdHgucmVzcG9uc2VgXG4gIC8vIDxodHRwczovL2dpdGh1Yi5jb20vcGlub2pzL2tvYS1waW5vLWxvZ2dlci9pc3N1ZXMvMTQ+XG4gIC8vIDxodHRwczovL2dpdGh1Yi5jb20vcGlub2pzL2tvYS1waW5vLWxvZ2dlci9ibG9iL21hc3Rlci9sb2dnZXIuanMjTDExPlxuICAvLyA8aHR0cHM6Ly9naXRodWIuY29tL3Bpbm9qcy9waW5vLWh0dHAvYmxvYi9tYXN0ZXIvbG9nZ2VyLmpzI0w1NT5cbiAgaWYgKGlzRXhwcmVzcykge1xuICAgIHJlcXVlc3QubG9nID0gbG9nZ2VyO1xuICAgIHJlcy5sb2cgPSBsb2dnZXI7XG4gICAgcmVxdWVzdC5sb2dnZXIgPSBsb2dnZXI7XG4gICAgcmVzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjdHggPSBhcmdzWzBdO1xuICAgIGN0eC5sb2cgPSBsb2dnZXI7XG4gICAgY3R4LmxvZ2dlciA9IGxvZ2dlcjtcbiAgICBjdHgucmVxdWVzdC5sb2cgPSBsb2dnZXI7XG4gICAgY3R4LnJlcXVlc3QubG9nZ2VyID0gbG9nZ2VyO1xuICAgIGN0eC5yZXNwb25zZS5sb2cgPSBsb2dnZXI7XG4gICAgY3R4LnJlc3BvbnNlLmxvZ2dlciA9IGxvZ2dlcjtcbiAgfVxuXG4gIHJldHVybiBuZXh0KCk7XG59O1xuIl19